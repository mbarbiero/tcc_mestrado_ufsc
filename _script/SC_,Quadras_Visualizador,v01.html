<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>SuperCIATA - GEO Real v3</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body { margin: 0; background: #2c3e50; display: flex; flex-direction: column; justify-content: center; align-items: center; min-height: 100vh; font-family: 'Segoe UI', sans-serif; }
        #input-area { width: 800px; background: #fff; padding: 15px; border-radius: 8px 8px 0 0; box-sizing: border-box; border-bottom: 2px solid #eee; }
        textarea { width: 100%; height: 60px; border: 1px solid #ccc; border-radius: 4px; padding: 8px; font-family: monospace; font-size: 11px; resize: none; }
        .btn-generate { background: #2980b9; color: white; border: none; padding: 10px; width: 100%; border-radius: 4px; cursor: pointer; margin-top: 10px; font-weight: bold; }
        #map-container { width: 800px; height: 600px; position: relative; background: #fff; box-shadow: 0 10px 30px rgba(0,0,0,0.3); display: none; }
        #map { width: 100%; height: 100%; }
        .info-panel { position: absolute; top: 15px; left: 15px; z-index: 1001; background: rgba(255, 255, 255, 0.95); padding: 15px; border-radius: 4px; border-left: 5px solid #2980b9; width: 240px; box-shadow: 0 2px 10px rgba(0,0,0,0.1); }
        .edge-label { background: #2980b9; color: white; padding: 1px 4px; border-radius: 3px; font-size: 10px; font-weight: bold; border: 1px solid #fff; }
        .btn-copy { margin-top: 10px; width: 100%; padding: 8px; background: #333; color: white; border: none; cursor: pointer; font-size: 11px; border-radius: 3px; }
    </style>
</head>
<body>

    <div id="input-area">
        <textarea id="json-input" placeholder="Cole o JSON da quadra..."></textarea>
        <button class="btn-generate" onclick="gerarGeoReal()">Gerar GEO Real</button>
    </div>

    <div id="map-container">
        <div class="info-panel">
            <div style="font-size: 11px; color: #2980b9; font-weight: bold;">SuperCIATA</div>
            <h2 style="margin: 0; font-size: 18px; color: #1a252f;">GEO Real</h2>
            <div id="info-content" style="font-size: 11px; color: #333; margin-top:8px;">
                <b>Quadra:</b> <span id="label-codigo" style="word-break: break-all;">-</span><br>
                <b>Rua Ref:</b> <span id="label-rua">-</span>
            </div>
            <div id="coords-list" style="margin-top:10px; font-size:10px; border-top:1px solid #eee; padding-top:8px; max-height: 150px; overflow-y: auto;"></div>
            <button class="btn-copy" id="btn-wkt">Copiar WKT</button>
        </div>
        <div id="map"></div>
    </div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script>
        let map;
        const R = 6378137;

        async function gerarGeoReal() {
            const input = document.getElementById('json-input').value;
            if(!input) return;
            try {
                const data = JSON.parse(input);
                const f1 = data.faces.find(f => f.ordem_face === 1);
                const f3 = data.faces.find(f => f.ordem_face === 3);

                document.getElementById('label-codigo').innerText = data.sc_id_quadra;
                document.getElementById('label-rua').innerText = f1.nome_logradouro;
                document.getElementById('map-container').style.display = 'block';

                const osmNodes = await fetchOSM(f1.centroide, f1.nome_logradouro);
                const streetAngle = calculateAngle(osmNodes, f1.centroide);
                
                // Determina se a Face 3 está à "esquerda" ou "direita" do vetor da rua
                // para decidir se projeta para um lado ou para o outro
                const vertices = computeVertices(f1.centroide, f3.centroide, data.faces, streetAngle);
                
                renderMap(vertices);
            } catch (e) { alert("Erro: " + e.message); }
        }

        async function fetchOSM(c, rua) {
            const query = `[out:json];way["name"~"${rua}",i](around:100,${c.lat},${c.lng});out geom;`;
            const res = await fetch("https://overpass-api.de/api/interpreter", { method: "POST", body: query });
            const d = await res.json();
            if(!d || !d.elements.length) throw new Error("Rua não encontrada no OSM");
            const g = d.elements[0].geometry;
            return g.sort((a,b) => Math.hypot(a.lat-c.lat, a.lon-c.lng) - Math.hypot(b.lat-c.lat, b.lon-c.lng)).slice(0,2);
        }

        function calculateAngle(pts, c) {
            return Math.atan2(pts[1].lat - pts[0].lat, (pts[1].lon - pts[0].lon) * Math.cos(c.lat * Math.PI / 180));
        }

        function computeVertices(c1, c3, faces, angle) {
            const d = {}; faces.forEach(f => d[f.ordem_face] = f.dim_face);
            
            const project = (dn, de) => {
                const re = de * Math.cos(angle) - dn * Math.sin(angle);
                const rn = de * Math.sin(angle) + dn * Math.cos(angle);
                return [c1.lat + (rn/R)*(180/Math.PI), c1.lng + (re/(R*Math.cos(c1.lat*Math.PI/180)))*(180/Math.PI)];
            };

            // Vértices da base (Face 1)
            const p1 = project(0, -d[1]/2);
            const p2 = project(0, d[1]/2);

            // Testamos a projeção para "frente" (1) e "trás" (-1)
            // e verificamos qual fica mais próxima do centroide real da Face 3
            const testV3_pos = project(d[2], d[1]/2);
            const testV3_neg = project(-d[2], d[1]/2);
            
            const distPos = Math.hypot(testV3_pos[0] - c3.lat, testV3_pos[1] - c3.lng);
            const distNeg = Math.hypot(testV3_neg[0] - c3.lat, testV3_neg[1] - c3.lng);
            
            const dir = distPos < distNeg ? 1 : -1;

            const v3 = project(dir * d[2], d[1]/2);
            const v4 = project(dir * d[4], -d[1]/2);

            // Retorna em ordem anti-horária garantida usando cross product simples
            const poly = [p1, p2, v3, v4];
            const area = poly.reduce((acc, curr, i) => {
                const next = poly[(i + 1) % poly.length];
                return acc + (next[1] - curr[1]) * (next[0] + curr[0]);
            }, 0);
            
            return area > 0 ? poly : [p1, v4, v3, p2];
        }

        function renderMap(v) {
            if(map) map.remove();
            map = L.map('map', { zoomControl: false, attributionControl: false });
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
            const poly = L.polygon(v, { color: '#2980b9', weight: 4, fillOpacity: 0.3 }).addTo(map);
            map.fitBounds(poly.getBounds(), { padding: [80, 80] });

            let html = "";
            v.forEach((p, i) => {
                L.circleMarker(p, { radius: 4, color: '#1a252f', fillColor: '#fff', fillOpacity: 1 }).addTo(map);
                const next = v[(i + 1) % v.length];
                const mid = [(p[0] + next[0])/2, (p[1] + next[1])/2];
                const dist = L.latLng(p).distanceTo(L.latLng(next));
                L.marker(mid, { icon: L.divIcon({ className: 'edge-label', html: dist.toFixed(1)+'m', iconSize:[45,18] }) }).addTo(map);
                html += `V${i+1}: ${p[0].toFixed(6)}, ${p[1].toFixed(6)}<br>`;
            });
            document.getElementById('coords-list').innerHTML = html;
            const wkt = `POLYGON((${v.map(p => `${p[1].toFixed(7)} ${p[0].toFixed(7)}`).join(', ')}, ${v[0][1].toFixed(7)} ${v[0][0].toFixed(7)}))`;
            document.getElementById('btn-wkt').onclick = () => { navigator.clipboard.writeText(wkt); alert("WKT Copiado!"); };
        }
    </script>
</body>
</html>
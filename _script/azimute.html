<!DOCTYPE html>
<html lang="pt-br">
<head>
    <meta charset="UTF-8">
    <title>SuperCIATA - Ajuste por Vértices Opostos</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        body { font-family: 'Segoe UI', sans-serif; margin: 0; padding: 20px; background: #f4f7f6; }
        #map { height: 600px; width: 100%; border-radius: 12px; }
        .panel { background: white; padding: 15px; border-radius: 10px; margin-bottom: 15px; border-left: 6px solid #2ecc71; }
        .stats { font-family: monospace; font-size: 11px; background: #2c3e50; color: #ecf0f1; padding: 10px; border-radius: 5px; margin-top: 10px; }
    </style>
</head>
<body>

<div class="panel">
    <h3>Ajuste por Vetor Oposto: Av. Paraná</h3>
    <p>O azimute é calculado entre os vértices que delimitam o trecho da via oposto ao centroide.</p>
    <div id="status">Buscando pontos cardeais da via...</div>
    <div class="stats" id="debug">Aguardando processamento...</div>
</div>
<div id="map"></div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script>
    const centroide = [-25.68020, -53.80171];
    const map = L.map('map').setView(centroide, 19);

    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png').addTo(map);
    L.circleMarker(centroide, { color: 'black', radius: 5, fillOpacity: 1 }).addTo(map);

    function getDist(c, v) {
        return Math.sqrt(Math.pow(c[0] - v.lat, 2) + Math.pow(c[1] - v.lon, 2));
    }

    function calcularAzimute(lat1, lon1, lat2, lon2) {
        const toRad = (v) => (v * Math.PI) / 180;
        const phi1 = toRad(lat1), phi2 = toRad(lat2);
        const dL = toRad(lon2 - lon1);
        const y = Math.sin(dL) * Math.cos(phi2);
        const x = Math.cos(phi1) * Math.sin(phi2) - Math.sin(phi1) * Math.cos(phi2) * Math.cos(dL);
        return ((Math.atan2(y, x) * 180 / Math.PI) + 360) % 360;
    }

    async function processarOpostos() {
        const query = `[out:json];way["name"~"Paraná"](around:150, ${centroide[0]}, ${centroide[1]});out geom;`;
        try {
            const res = await fetch("https://overpass-api.de/api/interpreter?data=" + encodeURIComponent(query));
            const data = await res.json();
            const vertices = data.elements[0].geometry;

            // 1. Achar o índice do vértice mais próximo
            let idxProximo = 0;
            let dMin = Infinity;
            vertices.forEach((v, i) => {
                let d = getDist(centroide, v);
                if (d < dMin) { dMin = d; idxProximo = i; }
            });

            // 2. Selecionar os OPOSTOS (Anterior e Posterior)
            // Caso seja o primeiro ou último, pegamos o vizinho imediato disponível
            const idxP1 = Math.max(0, idxProximo - 1);
            const idxP2 = Math.min(vertices.length - 1, idxProximo + 1);

            const p1 = vertices[idxP1];
            const p2 = vertices[idxP2];

            // Marcadores visuais dos pontos usados (Vermelho)
            L.circleMarker([p1.lat, p1.lon], { color: 'red', radius: 4 }).addTo(map).bindTooltip("Vértice Anterior");
            L.circleMarker([p2.lat, p2.lon], { color: 'red', radius: 4 }).addTo(map).bindTooltip("Vértice Posterior");

            // 3. Cálculo do Azimute
            const azReal = calcularAzimute(p1.lat, p1.lon, p2.lat, p2.lon);
            const anguloTrig = 90 - azReal; 
            
            const distLinha = 0.0006; 
            const rad = (anguloTrig * Math.PI) / 180;
            const latOff = Math.sin(rad) * distLinha;
            const lonOff = Math.cos(rad) * distLinha;

            const retaFinal = [
                [centroide[0] - latOff, centroide[1] - lonOff],
                [centroide[0] + latOff, centroide[1] + lonOff]
            ];

            // 4. Desenhar Reta Final (Azul)
            L.polyline(retaFinal, {color: '#1a73e8', weight: 6}).addTo(map)
                .bindPopup(`Azimute Oposto: ${azReal.toFixed(5)}°`).openPopup();

            document.getElementById('debug').innerHTML = 
                `VÉRTICE CENTRAL ID: ${idxProximo}<br>` +
                `PONTOS USADOS: V${idxP1} para V${idxP2}<br>` +
                `AZIMUTE MÉDIO: ${azReal.toFixed(5)}°`;
            
            document.getElementById('status').innerHTML = "<b>Cálculo por balanço de vizinhança concluído.</b>";

        } catch (e) { document.getElementById('status').innerText = "Erro ao localizar via."; }
    }

    processarOpostos();
</script>
</body>
</html>